<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Семантическая социальная сеть</title>
    <style>
        body {
            margin: 0;
            font-family: sans-serif;
            overflow: hidden;
        }

        #sidebar {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            z-index: 10;
            width: 220px;
            font-size: 14px;
        }

        #legend {
            margin-top: 15px;
            font-size: 13px;
            color: #555;
        }

        svg {
            width: 100vw;
            height: 100vh;
            cursor: move;
        }

        .link {
            stroke-width: 2.5;
            fill: none;
            stroke-opacity: 0.8;
            stroke-linecap: round;
        }

        .selected-link {
            stroke-width: 3px !important;
            stroke-opacity: 1;
            transition: stroke-opacity 0.3s ease;
        }

        .link.dimmed {
            stroke: #ccc;
            stroke-opacity: 0.3;
            pointer-events: none;
        }

        .link.loop {
            stroke: #cf5ff5;
            stroke-width: 3;
        }

        .node-group {
            cursor: pointer;
        }

        .node-circle {
            stroke: #fff;
            stroke-width: 1.5px;
        }

        .node-text {
            font-size: 18px;
            text-anchor: middle;
            pointer-events: none;
            fill: #000000;
            dy: 0.35em;
        }

        .node-popup {
            position: absolute;
            right: 20px;
            top: 50%;
            width: 250px;
            background: rgba(255, 255, 255, 0.98);
            border-radius: 10px;
            box-shadow: 0 2px 15px rgba(0, 0, 0, 0.2);
            padding: 15px;
            z-index: 20;
            border-left: 4px solid #d33;
            display: none;
            font-size: 14px;
            line-height: 1.5;
            opacity: 0;
            transform: translateY(-50%) translateX(20px);
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        .node-popup.show {
            opacity: 1;
            transform: translateY(-50%) translateX(0);
            display: block;
        }

        .node-popup h3 {
            margin-top: 0;
            color: #d33;
            border-bottom: 1px solid #eee;
            padding-bottom: 8px;
        }

        .node-popup .close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            cursor: pointer;
            font-weight: bold;
            color: #999;
        }

        .node-popup .close-btn:hover {
            color: #d33;
        }

        .tooltip {
            position: absolute;
            padding: 6px;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            border-radius: 4px;
            pointer-events: none;
            font-size: 12px;
            z-index: 10;
        }

        .highlight .node-circle {
            stroke: red !important;
            /* Красная обводка */
            stroke-width: 5px !important;
        }

        .dimmed {
            opacity: 0.2;
            pointer-events: none;
        }

        .letter-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            display: none;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .letter-modal.show {
            opacity: 1;
            display: flex;
        }

        .letter-modal-content {
            background: white;
            width: 90%;
            max-width: 900px;
            max-height: 90vh;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 5px 25px rgba(0, 0, 0, 0.3);
            overflow: auto;
        }

        .letter-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #eee;
        }

        .letter-modal-title {
            margin: 0;
            color: #d33;
            font-size: 20px;
            font-weight: bold;
        }

        .letter-modal-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #999;
            padding: 5px;
        }

        .letter-modal-close:hover {
            color: #d33;
        }

        .letter-modal-text {
            white-space: pre-wrap;
            font-family: 'Courier New', Courier, monospace;
            font-size: 14px;
            line-height: 1.6;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            max-height: 60vh;
            overflow-y: auto;
            border: 1px solid #eee;
        }

        .letter-modal-footer {
            margin-top: 20px;
            text-align: right;
        }

        .letter-modal-button {
            background: #f0f0f0;
            border: 1px solid #ddd;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
        }

        .letter-modal-button:hover {
            background: #e0e0e0;
        }

        #letterContent {
            transition: opacity 0.3s ease;
            opacity: 0;
            pointer-events: none;
        }

        .letter-modal-container {
            display: flex;
            width: 100%;
            gap: 20px;
        }

        .letter-modal-text-container {
            flex: 2;
            min-width: 0;
        }

        .letter-meta-container {
            flex: 1;
            min-width: 300px;
            background: #f5f5f5;
            border-radius: 6px;
            padding: 15px;
        }

        .letter-meta-title {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 15px;
            color: #333;
            border-bottom: 1px solid #ddd;
            padding-bottom: 5px;
        }

        .letter-meta-item {
            margin-bottom: 10px;
        }

        .letter-meta-label {
            font-weight: bold;
            color: #555;
            font-size: 13px;
        }

        .letter-meta-value {
            color: #2c3e50;
            font-weight: normal;
        }

        #yearFilter {
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 5px;
            margin-top: 5px;
            background-color: white;
        }

        #yearFilter option {
            padding: 3px;
        }

        #yearFilter option:hover {
            background-color: #f0f0f0;
        }

        #resetFilter {
            background-color: #f8f8f8;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 5px 10px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        #resetFilter:hover {
            background-color: #e8e8e8;
        }

        .error {
            color: #d33;
        }

        #searchResultsContainer {
            max-height: 70vh;
            overflow-y: auto;
            margin-top: 15px;
        }

        .search-result {
            position: relative;
            padding: 15px;
            padding-right: 90px;
        }

        .score-badge {
            position: absolute;
            top: 15px;
            right: 15px;
            background: #e8f0fe;
            color: #1967d2;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.8em;
        }

        .search-result:hover {
            background: #f8f9fa;
            transform: translateX(5px);
        }

        .search-result h4 {
            margin: 0 0 8px 0;
            color: #1a73e8;
            font-size: 16px;
        }

        .search-result .excerpt {
            color: #444;
            font-size: 0.95em;
            line-height: 1.5;
            margin: 8px 0;
        }

        .search-result .meta {
            font-size: 0.85em;
            color: #666;
            margin-bottom: 8px;
        }

        .highlight {
            background-color: #ffeb3b;
            color: #000;
            padding: 2px 3px;
            border-radius: 3px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(0, 0, 0, .3);
            border-radius: 50%;
            border-top-color: #000;
            animation: spin 1s ease-in-out infinite;
        }

        #searchContainer {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 450px;
            background: rgba(255, 255, 255, 0.98);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            z-index: 10;
        }

        #searchContainer h3 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #333;
        }

        #fullTextSearch {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }

        .exact-badge {
            display: inline-block;
            background-color: #28a745;
            color: white;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            text-align: center;
            line-height: 18px;
            font-size: 12px;
            margin-left: 5px;
        }

        .loading-state {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            color: #666;
        }

        .loading-spinner {
            border: 3px solid rgba(0, 0, 0, 0.1);
            border-radius: 50%;
            border-top: 3px solid #007bff;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        .info-message,
        .error-message {
            padding: 20px;
            text-align: center;
            color: #666;
        }

        .error-details {
            font-size: 0.9em;
            color: #dc3545;
            margin-top: 5px;
        }

        .link-count {
            pointer-events: none;
            font-weight: bold;
            text-shadow: 0 0 3px white;
        }

        .link.dimmed+.link-count {
            opacity: 0.3;
        }

        .link.fixed {
            stroke-width: 6px !important;
            stroke: #ff0000 !important;
            /* Красный цвет для фиксированного ребра */
        }

        .scrollable-list {
            max-height: 200px;
            overflow-y: auto;
            overflow-x: auto;
            margin-top: 5px;
            border: 1px solid #eee;
            border-radius: 6px;
            padding: 5px;
        }

        .collective-link {
            stroke-dasharray: 5, 5;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body>
    <div id="sidebar">
        <label>Мин. связей: <input type="number" id="minLinks" value="0" min="0" style="width: 50px"></label><br>
        <label>Поиск: <input type="text" id="search" placeholder="Имя"></label>
        <div>
            <label>Год:
                <select id="yearFilter" multiple style="width: 100%; height: 100px;"></select>
            </label>
            <button id="resetFilter" style="margin-top: 5px; width: 100%;">Сбросить фильтр</button>
        </div>
        <div id="legend">
            <p><strong>Легенда:</strong></p>
            <ul>
                <li>Размер круга — активность</li>
                <li>Синие узлы — Персоны</li>
                <li>Желтые узлы — Коллективное авторство</li>
                <li>Зеленые ребра — взаимная переписка</li>
                <li>Фиолетовые ребра — Петля</li>
                <li>Красная обводка — выделенный узел/ребро</li>
            </ul>
        </div>
    </div>
    <div class="tooltip" id="tooltip" style="opacity:0;"></div>
    <div id="nodePopup" class="node-popup">
        <span class="close-btn" onclick="closePopup()">×</span>
        <h3 id="popupTitle"></h3>
        <div id="popupContent"></div>
    </div>
    <div id="searchContainer">
        <h3>Интеллектуальный поиск</h3>
        <input type="text" id="fullTextSearch"
            placeholder="Введите фразу для поиска (например, 'Русско-турецкая война')">
        <div id="searchResultsContainer"></div>
    </div>
    <svg>
        <defs>
            <marker id="arrow" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="6" markerHeight="6" orient="auto">
                <path d="M0,0 L10,5 L0,10 Z" fill="#ff6b00" />
            </marker>
            <marker id="arrow-bid" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="6" markerHeight="6" orient="auto">
                <path d="M0,0 L10,5 L0,10 Z" fill="#2abd28" />
            </marker>
            <marker id="loop-arrow" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="6" markerHeight="6"
                orient="auto">
                <path d="M0,0 L10,5 L0,10 Z" fill="#cf5ff5" />
            </marker>
            <filter id="loop-glow" x="-20%" y="-20%" width="140%" height="140%">
                <feGaussianBlur stdDeviation="2" result="blur" />
                <feComposite in="SourceGraphic" in2="blur" operator="over" />
            </filter>
        </defs>
        <g class="zoom-group"></g>
    </svg>
    <script src="https://d3js.org/d3.v7.min.js "></script>
    <script>
        const svg = d3.select('svg');
        const container = svg.select('.zoom-group');
        const tooltip = d3.select('#tooltip');
        let simulation = null;
        let maps = { degree: {}, out: {}, in: {}, meta: {}, myself: {} };
        const zoom = d3.zoom()
            .scaleExtent([0.1, 5])
            .on('zoom', (event) => {
                container.attr('transform', event.transform);
            });
        svg.call(zoom);
        d3.json("../../../docs/clean_results/jsons/10merged_json.json").then(data => {
            const years = [...new Set(data.map(d => d.Год))].sort((a, b) => a - b);
            d3.select('#yearFilter')
                .selectAll('option')
                .data(years)
                .enter()
                .append('option')
                .attr('value', d => d)
                .text(d => d);
            init(data);
        }).catch(error => {
            console.error('Ошибка загрузки данных:', error);
            alert('Ошибка загрузки данных! Проверьте консоль для деталей.');
        });
        let originalData = null;
        function init(data) {
            originalData = data;
            let selectedYears = [];
            function safeUpdate() {
                try {
                    updateVisualization(selectedYears.length > 0 ? filterData(data, selectedYears) : originalData, selectedYears);
                } catch (error) {
                    console.error("Ошибка при обновлении:", error);
                    container.selectAll("*").remove();
                    container.append("text")
                        .attr("x", 100)
                        .attr("y", 100)
                        .text("Ошибка визуализации: " + error.message);
                }
            }
            d3.select('#resetFilter').on('click', function () {
                d3.select('#yearFilter').property('selectedIndex', -1);
                d3.select('#minLinks').property('value', '0');
                d3.select('#search').property('value', '');
                container.selectAll('.highlight').classed('highlight', false);
                container.selectAll('.dimmed').classed('dimmed', false);
                container.selectAll('.selected-link').classed('selected-link', false);
                updateVisualization(originalData, []);
                updateHighlight();
            });
            d3.select('#minLinks').on('input', safeUpdate);
            d3.select('#search').on('input', updateHighlight);
            d3.select('#yearFilter').on('change', function () {
                selectedYears = Array.from(this.selectedOptions, opt => +opt.value);
                safeUpdate();
            });
            const years = [...new Set(data.map(d => d.Год))].sort((a, b) => a - b);
            d3.select('#yearFilter')
                .selectAll('option')
                .data(years)
                .enter()
                .append('option')
                .attr('value', d => d)
                .text(d => d);
            safeUpdate();
        }
        let searchIndex = null;
        let letterTexts = [];
        function updateVisualization(dataToShow, selectedYears) {
            if (simulation) {
                simulation.stop();
                simulation.nodes([]);
                simulation.force('link').links([]);
                simulation = null;
            }
            container.selectAll('*').remove();
            resetMaps(maps);
            calculateMetrics(dataToShow, maps);
            let { links, nodes } = processData(dataToShow, maps);
            const minLinks = +d3.select('#minLinks').property('value') || 0;
            nodes = nodes.filter(node =>
                (maps.degree[node.id] || 0) >= minLinks
            );
            if (nodes.length === 0) {
                container.append("text")
                    .attr("x", 100)
                    .attr("y", 100)
                    .text("Нет данных для отображения");
                return;
            }
            const remainingNodes = new Set(nodes.map(n => n.id));
            const validLinks = links.filter(l =>
                remainingNodes.has(l.source) &&
                (l.isLoop || remainingNodes.has(l.target))
            );
            if (nodes.length > 0 && validLinks.length >= 0) {
                simulation = createSimulation(nodes, validLinks, maps);
                drawElements(validLinks, nodes, simulation);
            }
        }
        function resetMaps(maps) {
            Object.keys(maps.degree).forEach(k => delete maps.degree[k]);
            Object.keys(maps.out).forEach(k => delete maps.out[k]);
            Object.keys(maps.in).forEach(k => delete maps.in[k]);
            Object.keys(maps.myself).forEach(k => delete maps.myself[k]);
            Object.keys(maps.meta).forEach(k => delete maps.meta[k]);
        }
        function filterData(data, selectedYears) {
            return selectedYears.length > 0
                ? data.filter(d => selectedYears.includes(d.Год))
                : data;
        }
        function calculateMetrics(data, maps) {
            data.forEach(d => {
                const senders = Array.isArray(d.Отправитель) ? d.Отправитель : [d.Отправитель];
                const receivers = Array.isArray(d.Получатель)
                    ? d.Получатель
                    : (d.Получатель ? [d.Получатель] : []);

                // Обновление метаданных для всех отправителей
                senders.forEach(sender => {
                    if (!maps.meta[sender]) maps.meta[sender] = {
                        numbers: new Set(),
                        texts: {},
                        titles: {},
                        fullData: {}
                    };
                    maps.meta[sender].numbers.add(d.Номер_в_издании);
                    maps.meta[sender].texts[d.Номер_в_издании] = d.Текст;
                    maps.meta[sender].titles[d.Номер_в_издании] = d.Название;
                    maps.meta[sender].fullData[d.Номер_в_издании] = d;
                    maps.out[sender] = (maps.out[sender] || 0) + 1;
                    maps.degree[sender] = (maps.degree[sender] || 0) + 1;
                });

                // Обработка получателей
                if (receivers.length === 0) {
                    senders.forEach(sender => {
                        maps.myself[sender] = (maps.myself[sender] || 0) + 1;
                    });
                } else {
                    receivers.forEach(receiver => {
                        if (!maps.meta[receiver]) maps.meta[receiver] = {
                            numbers: new Set(),
                            texts: {},
                            titles: {},
                            fullData: {}
                        };
                        maps.meta[receiver].numbers.add(d.Номер_в_издании);
                        maps.meta[receiver].texts[d.Номер_в_издании] = d.Текст;
                        maps.meta[receiver].titles[d.Номер_в_издании] = d.Название;
                        maps.meta[receiver].fullData[d.Номер_в_издании] = d;

                        maps.in[receiver] = (maps.in[receiver] || 0) + senders.length;
                        maps.degree[receiver] = (maps.degree[receiver] || 0) + senders.length;
                    });
                }
            });
        }
        function processData(data, maps) {
            const links = [];
            const linkCounts = {};
            const nodeSet = new Set();

            data.forEach(d => {
                const senders = Array.isArray(d.Отправитель) ? d.Отправитель : [d.Отправитель];
                const receivers = Array.isArray(d.Получатель)
                    ? d.Получатель
                    : (d.Получатель ? [d.Получатель] : []);

                // Добавление узлов для всех отправителей
                senders.forEach(sender => nodeSet.add(sender));

                // Обработка петель (отправитель = получатель)
                if (receivers.length === 0 ||
                    (receivers.length === 1 && senders.includes(receivers[0]))) {

                    senders.forEach(sender => {
                        const key = `${sender}→${sender}`;
                        if (!linkCounts[key]) linkCounts[key] = { count: 0, numbers: [] };
                        linkCounts[key].count++;
                        linkCounts[key].numbers.push(d.Номер_в_издании);

                        links.push({
                            source: sender,
                            target: sender,
                            isLoop: true,
                            count: linkCounts[key].count,
                            numbers: [...new Set(linkCounts[key].numbers)],
                            countAtoB: linkCounts[key].count,
                            countBtoA: 0
                        });
                    });
                } else {
                    // Добавление узлов для всех получателей
                    receivers.forEach(receiver => nodeSet.add(receiver));

                    // Генерация всех возможных пар (отправитель → получатель)
                    senders.forEach(sender => {
                        receivers.forEach(receiver => {
                            const key = `${sender}→${receiver}`;
                            const reverseKey = `${receiver}→${sender}`;

                            if (!linkCounts[key]) linkCounts[key] = { count: 0, numbers: [] };
                            if (!linkCounts[reverseKey]) linkCounts[reverseKey] = { count: 0, numbers: [] };

                            linkCounts[key].count++;
                            linkCounts[key].numbers.push(d.Номер_в_издании);

                            const isBidirectional = linkCounts[reverseKey].count > 0;
                            const existingLink = links.find(l =>
                                (l.source === sender && l.target === receiver) ||
                                (l.source === receiver && l.target === sender)
                            );

                            if (existingLink) {
                                if (existingLink.source === sender) {
                                    existingLink.countAtoB = linkCounts[key].count;
                                } else {
                                    existingLink.countBtoA = linkCounts[key].count;
                                }
                                existingLink.count = existingLink.countAtoB + existingLink.countBtoA;
                                existingLink.bidirectional = isBidirectional;
                                existingLink.numbers = [...new Set([...existingLink.numbers, d.Номер_в_издании])];
                            } else {
                                links.push({
                                    source: sender,
                                    target: receiver,
                                    isLoop: false,
                                    count: 1,
                                    numbers: [d.Номер_в_издании],
                                    countAtoB: 1,
                                    countBtoA: 0,
                                    bidirectional: false
                                });
                            }
                        });
                    });
                }
            });

            const nodes = Array.from(nodeSet).map(id => ({ id }));
            return { nodes, links };
        }
        function createSimulation(nodes, links, maps) {
            if (!nodes || !links || nodes.length === 0) {
                console.error("Некорректные данные:", { nodes, links });
                return null;
            }
            const filteredDegree = {};
            nodes.forEach(node => {
                filteredDegree[node.id] = maps.degree[node.id];
            });
            const radiusScale = d3.scaleSqrt()
                .domain([0, d3.max(Object.values(filteredDegree))])
                .range([8, 50]);
            const nodeCount = nodes.length;
            let distance, strength, chargeStrength, collideRadiusPadding;
            if (nodeCount < 50) {
                distance = 500;
                strength = 0.2;
                chargeStrength = -300;
                collideRadiusPadding = 30;
            } else if (nodeCount < 200) {
                distance = 500;
                strength = 0.1;
                chargeStrength = -450;
                collideRadiusPadding = 40;
            } else {
                distance = 600;
                strength = 0.9;
                chargeStrength = -2000;
                collideRadiusPadding = 70;
            }
            const simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links)
                    .id(d => d.id)
                    .distance(distance)
                    .strength(strength))
                .force('charge', d3.forceManyBody()
                    .strength(chargeStrength)
                    .distanceMax(distance * 1.5))
                .force('collide', d3.forceCollide()
                    .radius(d => radiusScale(filteredDegree[d.id]) + collideRadiusPadding)
                    .strength(0.8))
                .force('center', d3.forceCenter(window.innerWidth / 2, window.innerHeight / 2))
                .force('x', d3.forceX().strength(0.05))
                .force('y', d3.forceY().strength(0.05))

                .alphaDecay(0.003)
                .velocityDecay(0.9)
                .alphaMin(0.001);
            simulation.restart();
            return simulation;
        }
        function drawElements(validLinks, filteredNodes, simulation) {
            const regularLinks = validLinks.filter(d => !d.isLoop);
            const loopLinks = validLinks.filter(d => d.isLoop);
            const linkGroup = container.append('g').attr('class', 'links');
            const linkPaths = linkGroup.selectAll('.link.regular')
                .data(regularLinks)
                .enter().append('path')
                .attr('class', d => `link regular ${d.isCollective ? 'collective-link' : ''}`)
                .attr('stroke', d => d.bidirectional ? '#2abd28' : '#ffa600')
                .attr('stroke-width', 1.5)
                .attr('fill', 'none')
                .attr('marker-end', d => `url(#${d.bidirectional ? 'arrow-bid' : 'arrow'})`)
                .on('mouseover', function (event, d) {
                    if (d.bidirectional) {
                        tooltip.style('opacity', 1)
                            .html(`<strong>Количество писем:</strong><br>
                             Всего: <strong>${d.count}</strong><br>
                                    ${d.source.id} → ${d.target.id}: <strong>${d.countAtoB}</strong><br>
                                    ${d.target.id} → ${d.source.id}: <strong>${d.countBtoA}</strong><br>
                                   `);
                    } else {
                        tooltip.style('opacity', 1)
                            .html(`<strong>${d.source.id} → ${d.target.id}</strong><br>Количество писем: <strong>${d.count}</strong>`);
                    }
                })
                .on('mousemove', updateTooltipPosition)
                .on('mouseout', function () {
                    // Не скрывать tooltip, если ребро зафиксировано
                    if (!d3.select(this).classed('fixed')) {
                        tooltip.style('opacity', 0);
                    }
                })
                .on('click', function (event, d) {
                    event.stopPropagation();
                    const link = d3.select(this);
                    const isFixed = link.classed('fixed');
                    // Сброс фиксации у всех ребер
                    container.selectAll('.link.fixed').classed('fixed', false);
                    if (!isFixed) {
                        // Зафиксировать текущее ребро
                        link.classed('fixed', true);
                        // Обновить tooltip
                        tooltip.style('opacity', 1);
                        // Выделить связанные узлы
                        const sourceNode = d.source.id;
                        const targetNode = d.target.id;
                        // Сброс всех выделений
                        container.selectAll('.highlight').classed('highlight', false);
                        container.selectAll('.dimmed').classed('dimmed', false);
                        // Выделить source и target
                        container.selectAll('.node-group')
                            .filter(n => n.id === sourceNode || n.id === targetNode)
                            .classed('highlight', true);
                        // Приглушить остальные узлы
                        container.selectAll('.node-group')
                            .filter(n => n.id !== sourceNode && n.id !== targetNode)
                            .classed('dimmed', true);
                        // Приглушить несвязанные ребра
                        container.selectAll('.link')
                            .filter(l => l.source.id !== sourceNode || l.target.id !== targetNode)
                            .classed('dimmed', true);

                        // Показать popup с письмами
                        showLinkPopup(d, sourceNode, targetNode);
                    } else {
                        // Скрыть tooltip и сбросить выделения
                        tooltip.style('opacity', 0);
                        container.selectAll('.highlight').classed('highlight', false);
                        container.selectAll('.dimmed').classed('dimmed', false);
                    }
                });
            const loopGroup = container.append('g').attr('class', 'loops');
            const loopPaths = loopGroup.selectAll('.link.loop')
                .data(loopLinks)
                .enter().append('path')
                .attr('class', 'link loop')
                .attr('stroke', '#cf5ff5')
                .attr('stroke-width', 2)
                .attr('fill', 'none')
                .attr('marker-end', 'url(#loop-arrow)')
                .on('mouseover', function (event, d) {
                    tooltip.style('opacity', 1)
                        .html(`<strong>${d.source.id} → ${d.source.id}</strong><br>Писем: ${d.count}`);
                })
                .on('mousemove', updateTooltipPosition)
                .on('mouseout', function () {
                    tooltip.style('opacity', 0);
                });
            const nodeG = container.append('g').attr('class', 'nodes')
                .selectAll('.node-group')
                .data(filteredNodes)
                .enter().append('g')
                .attr('class', 'node-group')
                .call(d3.drag()
                    .on('start', dragStarted)
                    .on('drag', dragged)
                    .on('end', dragEnded));
            const radiusScale = d3.scaleSqrt()
                .domain([0, d3.max(Object.values(maps.degree))])
                .range([10, 70]);
            nodeG.append('circle')
                .attr('class', 'node-circle')
                .attr('r', d => radiusScale(maps.degree[d.id]))
                .attr('fill', d => d.id.match(/[«»]/) ? '#fffb05' : '#00027a');
            nodeG.append('text')
                .attr('class', 'node-text')
                .attr('y', d => radiusScale(maps.degree[d.id]) + 30)
                .text(d => d.id);
            simulation.on('tick', () => {
                linkPaths.attr('d', d => {
                    const dx = d.target.x - d.source.x;
                    const dy = d.target.y - d.source.y;
                    const dr = Math.sqrt(dx * dx + dy * dy);
                    const targetRadius = radiusScale(maps.degree[d.target.id]);
                    const ratio = (dr - targetRadius) / dr;
                    const tx = d.source.x + dx * ratio;
                    const ty = d.source.y + dy * ratio;
                    return `M${d.source.x},${d.source.y}L${tx},${ty}`;
                });
                loopPaths.attr('d', d => {
                    const r = radiusScale(maps.degree[d.source.id]) + 20;
                    return `M${d.source.x},${d.source.y - r}
                              A${r} ${r} 0 1 1 ${d.source.x},${d.source.y + r}
                              A${r} ${r} 0 1 1 ${d.source.x},${d.source.y - r}`;
                });
                nodeG.attr('transform', d => `translate(${d.x},${d.y})`);
            });
            nodeG.on('click', function (event, d) {
                event.stopPropagation();
                const isActive = d3.select(this).classed('highlight');
                container.selectAll('.highlight').classed('highlight', false);
                container.selectAll('.dimmed').classed('dimmed', false);
                container.selectAll('.selected-link').classed('selected-link', false);
                container.selectAll('.link-count').remove();
                if (!isActive) {
                    d3.select(event.currentTarget).classed('highlight', true);
                    const connectedNodes = new Set([d.id]);
                    container.selectAll('.link')
                        .filter(l => l.source.id === d.id || l.target.id === d.id)
                        .each(function (l) {
                            connectedNodes.add(l.source.id);
                            connectedNodes.add(l.target.id);
                            d3.select(this).classed('selected-link', true);
                        });
                    container.selectAll('.node-group')
                        .classed('dimmed', node => !connectedNodes.has(node.id));
                    container.selectAll('.link')
                        .classed('dimmed', link =>
                            link.source.id !== d.id && link.target.id !== d.id
                        );
                    showNodePopup(d);
                }
            });

            nodeG.on('mouseover', showTooltip)
                .on('mousemove', updateTooltipPosition)
                .on('mouseout', hideTooltip);
            svg.on('click', () => {
                container.selectAll('.highlight').classed('highlight', false);
                container.selectAll('.dimmed').classed('dimmed', false);
                container.selectAll('.selected-link').classed('selected-link', false);
                container.selectAll('.link-count').remove();
                closePopup();

                // Сброс фиксации ребер и tooltip
                container.selectAll('.link.fixed').classed('fixed', false);
                tooltip.style('opacity', 0); // Скрыть tooltip
            });
        }
        function showNodePopup(nodeData) {
            const popup = d3.select('#nodePopup');
            const metaData = maps.meta[nodeData.id];

            // Объединение данных из всех писем
            let metaText = 'нет данных';
            let textsHtml = '';
            if (metaData && metaData.numbers && metaData.numbers.size > 0) {
                metaText = Array.from(metaData.numbers).join(', ');
                textsHtml = `
            <div style="margin-top: 15px;">
                <strong>Письма:</strong>
                <div style="max-height: 200px; overflow-y: auto; margin-top: 5px;">
                    <ul style="list-style-type: none; padding-left: 0; margin: 0;">
                        ${Array.from(metaData.numbers).sort((a, b) => a - b).map(num => {
                    const title = metaData.titles[num] || 'Без названия';
                    return `
                            <li style="margin-bottom: 5px; border-bottom: 1px solid #eee; padding-bottom: 5px;">
                                <a href="#" class="letter-link" data-num="${num}" 
                                   style="color: #0066cc; text-decoration: none; display: block;"
                                   onmouseover="this.style.textDecoration='underline'" 
                                   onmouseout="this.style.textDecoration='none'">
                                    №${num}. ${title}
                                </a>
                            </li>
                        `;
                }).join('')}
                    </ul>
                </div>
            </div>
        `;
            }
            popup.select('#popupTitle').text(nodeData.id);
            popup.select('#popupContent').html(`
        <p><strong>Всего:</strong> ${maps.degree[nodeData.id] || 0}</p>
        <p><strong>Исходящих:</strong> ${maps.out[nodeData.id] || 0}</p>
        <p><strong>Входящих:</strong> ${maps.in[nodeData.id] || 0}</p>
        <p><strong>Без получателя:</strong> ${maps.myself[nodeData.id] || 0}</p>
        <p><strong>Номера в издании:</strong> ${metaText}</p>
        ${textsHtml}
    `);
            popup.selectAll('.letter-link').on('click', function (event) {
                event.preventDefault();
                const num = d3.select(this).attr('data-num');
                const letterData = metaData.fullData[num];
                if (letterData) {
                    showLetterModal(letterData);
                } else {
                    console.error('Данные письма не найдены:', num);
                    alert('Ошибка загрузки данных письма');
                }
            });
            popup.classed('show', true);
        }
        function closePopup() {
            d3.select('#nodePopup').classed('show', false);
        }
        function showTooltip(event, d) {
            const metaData = maps.meta[d.id];
            let metaText = 'нет данных';
            if (metaData && metaData.numbers && metaData.numbers.size > 0) {
                metaText = Array.from(metaData.numbers).join(', ');
            }
            tooltip.style('opacity', 1).html(`
            <strong>${d.id}</strong><br>
            Всего писем: ${maps.degree[d.id] || 0}<br>
            Отправлено: ${maps.out[d.id] || 0}<br>
            Получено: ${maps.in[d.id] || 0}<br>
            Без получателя: ${maps.myself[d.id] || 0}
        `);
        }
        function showLinkPopup(linkData, sourceNode, targetNode) {
            const popup = d3.select('#nodePopup');
            let textsHtml = '<div style="margin-top: 15px;"><strong>Письма:</strong></div>';

            // Разделение писем по направлению
            const fromSource = [];
            const fromTarget = [];

            if (linkData.numbers && linkData.numbers.length > 0) {
                linkData.numbers.forEach(num => {
                    const letterData = originalData.find(d => d.Номер_в_издании == num);
                    if (!letterData) return;

                    if (letterData.Отправитель === sourceNode && letterData.Получатель === targetNode) {
                        fromSource.push({ num, title: letterData.Название || 'Без названия' });
                    } else if (letterData.Отправитель === targetNode && letterData.Получатель === sourceNode) {
                        fromTarget.push({ num, title: letterData.Название || 'Без названия' });
                    }
                });

                // Сортировка по номерам
                fromSource.sort((a, b) => a.num - b.num);
                fromTarget.sort((a, b) => a.num - b.num);

                // Формирование HTML для двух списков с прокруткой
                if (fromSource.length > 0) {
                    textsHtml += `
                <div style="margin-top: 10px;">
                    <strong>Отправитель ${sourceNode} <br>Получатель ${targetNode}:</strong>
                    <div class="scrollable-list">
                        <ul style="list-style-type: none; padding-left: 0; margin: 5px 0;">
                            ${fromSource.map(item => `
                                <li style="margin-bottom: 5px; border-bottom: 1px solid #eee; padding-bottom: 5px;">
                                    <a href="#" class="letter-link" data-num="${item.num}" 
                                       style="color: #0066cc; text-decoration: none; display: block;"
                                       onmouseover="this.style.textDecoration='underline'" 
                                       onmouseout="this.style.textDecoration='none'">
                                        №${item.num}. ${item.title}
                                    </a>
                                </li>
                            `).join('')}
                        </ul>
                    </div>
                </div>`;
                }

                if (fromTarget.length > 0) {
                    textsHtml += `
                <div style="margin-top: 10px;">
                    <strong>Отправитель ${targetNode}  <br>Получатель ${sourceNode}:</strong>
                    <div class="scrollable-list">
                        <ul style="list-style-type: none; padding-left: 0; margin: 5px 0;">
                            ${fromTarget.map(item => `
                                <li style="margin-bottom: 5px; border-bottom: 1px solid #eee; padding-bottom: 5px;">
                                    <a href="#" class="letter-link" data-num="${item.num}" 
                                       style="color: #0066cc; text-decoration: none; display: block;"
                                       onmouseover="this.style.textDecoration='underline'" 
                                       onmouseout="this.style.textDecoration='none'">
                                        №${item.num}. ${item.title}
                                    </a>
                                </li>
                            `).join('')}
                        </ul>
                    </div>
                </div>`;
                }
            } else {
                textsHtml += '<div style="margin-top: 10px;">Нет данных</div>';
            }

            // Обновление popup
            popup.select('#popupTitle').text(`Связь: ${sourceNode} → ${targetNode}`);
            popup.select('#popupContent').html(`
        <p><strong>Количество писем:</strong> ${linkData.count}</p>
        ${textsHtml}
    `);

            // Обработчик клика на письма
            popup.selectAll('.letter-link').on('click', function (event) {
                event.preventDefault();
                const num = d3.select(this).attr('data-num');
                const letterData = originalData.find(d => d.Номер_в_издании == num);
                if (letterData) {
                    showLetterModal(letterData);
                } else {
                    console.error('Данные письма не найдены:', num);
                    alert('Ошибка загрузки данных письма');
                }
            });

            popup.classed('show', true);
        }
        function updateTooltipPosition(event) {
            tooltip.style('left', `${event.pageX + 10}px`)
                .style('top', `${event.pageY + 10}px`);
        }
        function hideTooltip() {
            tooltip.style('opacity', 0);
        }
        function updateHighlight() {
            const term = d3.select('#search').property('value').toLowerCase();
            container.selectAll('.link-count').remove();
            container.selectAll('.node-group').classed('highlight', false);
            container.selectAll('.node-group').classed('dimmed', false);
            container.selectAll('.link').classed('dimmed', false);
            container.selectAll('.selected-link').classed('selected-link', false);
            if (!term) return;
            const matchingNodes = new Set();
            container.selectAll('.node-group').each(function (d) {
                if (d.id.toLowerCase().includes(term)) {
                    matchingNodes.add(d.id);
                }
            });
            const connectedNodes = new Set(matchingNodes);
            const connectedLinks = new Set();
            container.selectAll('.link').each(function (l) {
                const sourceMatch = matchingNodes.has(l.source.id);
                const targetMatch = matchingNodes.has(l.target.id);
                if (sourceMatch || targetMatch) {
                    connectedLinks.add(l);
                    if (!sourceMatch) connectedNodes.add(l.source.id);
                    if (!targetMatch) connectedNodes.add(l.target.id);
                }
            });
            container.selectAll('.node-group').classed('highlight', d => connectedNodes.has(d.id));
            container.selectAll('.node-group').classed('dimmed', d => !connectedNodes.has(d.id));
            container.selectAll('.link').classed('dimmed', l => {
                return !(connectedNodes.has(l.source.id) && connectedNodes.has(l.target.id));
            });
            container.selectAll('.link').classed('selected-link', l => {
                return matchingNodes.has(l.source.id) || matchingNodes.has(l.target.id);
            });
        }
        function dragStarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.001).restart();
            d.fx = d.x;
            d.fy = d.y;
        }
        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }
        function dragEnded(event, d) {
            if (!event.active) simulation.alphaTarget(0.01);
            d.fx = null;
            d.fy = null;
        }
        function showLetterModal(data) {
            if (!data) {
                console.error('Нет данных для отображения');
                return;
            }
            const safeData = {
                number: data.Номер_в_издании ?? 'Нет номера',
                title: data.Название?.trim() || 'Без названия',
                text: (data.Текст?.replace(/<<\d+>>/g, '') || 'Текст письма отсутствует').replace(/\n/g, '<br>'),
                sender: data.Отправитель || 'Неизвестный отправитель',
                receiver: data.Получатель || 'Неизвестный получатель',
                date: data.Дата || 'Дата не указана',
                location: data.Локация || 'Локация не указана',
                year: data.Год || 'Год не указан',
                source: (data.Источник?.replace(/\r/g, '<br>') || 'Источник отсутствует')
            };
            const titleElement = document.getElementById('letterModalTitle');
            const textElement = document.getElementById('letterModalText');
            const metaElement = document.getElementById('letterMetaContent');
            titleElement.innerHTML = `Письмо №${safeData.number}<br><small>${safeData.title}</small>`;
            textElement.innerHTML = safeData.text;
            metaElement.innerHTML = `
        <div class="letter-meta-item">
            <div class="letter-meta-label">От:</div>
            <div class="letter-meta-value">${safeData.sender}</div>
        </div>
        <div class="letter-meta-item">
            <div class="letter-meta-label">Кому:</div>
            <div class="letter-meta-value">${safeData.receiver}</div>
        </div>
        <div class="letter-meta-item">
            <div class="letter-meta-label">Дата:</div>
            <div class="letter-meta-value">${safeData.date}</div>
        </div>
        <div class="letter-meta-item">
            <div class="letter-meta-label">Место:</div>
            <div class="letter-meta-value">${safeData.location}</div>
        </div>
        <div class="letter-meta-item">
            <div class="letter-meta-label">Год:</div>
            <div class="letter-meta-value">${safeData.year}</div>
        </div>
        <div class="letter-meta-item">
            <div class="letter-meta-label">Источник:</div>
            <div class="letter-meta-value">${safeData.source}</div>
        </div>`;
            document.getElementById('letterModal').classList.add('show');
        }
        window.handleSearchResultClick = function (resultData) {
            showLetterModal(resultData);
        };
        function closeLetterModal() {
            document.getElementById('letterModal').classList.remove('show');
        }
        let searchTimeout;
        const debounce = (func, delay) => {
            let timeout;
            return (...args) => {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), delay);
            };
        };
        function parseSearchQuery(query) {
            const exactPhraseMatch = query.match(/"(.*?)"/);
            const exactPhrase = exactPhraseMatch ? exactPhraseMatch[1] : null;
            const wordsQuery = exactPhrase ? query.replace(`"${exactPhrase}"`, '').trim() : query;
            const words = wordsQuery.split(/\s+/).filter(word => word.length > 0);
            return {
                exactPhrase,
                words
            };
        }
        function combineResults(exactResults, wordResults) {
            const resultMap = new Map();
            exactResults.forEach(result => {
                resultMap.set(result.Номер_в_издании, {
                    ...result,
                    isExactMatch: true,
                    score: result.score * 1.5
                });
            });
            wordResults.forEach(result => {
                if (!resultMap.has(result.Номер_в_издании)) {
                    resultMap.set(result.Номер_в_издании, {
                        ...result,
                        isExactMatch: false
                    });
                }
            });
            return Array.from(resultMap.values()).sort((a, b) => b.score - a.score);
        }
        function displaySearchResults(results, query, container) {
            let html = '';
            const queryTerms = query.toLowerCase().split(/\s+/).filter(term => term.length > 0);
            results.forEach(result => {
                const safeResult = {
                    ...result,
                    Текст: result.Текст?.replace(/</g, '<').replace(/>/g, '>') || '',
                    excerpt: result.excerpt?.replace(/</g, '<').replace(/>/g, '>') || ''
                };
                const exactMatchBadge = result.isExactMatch
                    ? '<span class="exact-badge" title="Точное совпадение">✓</span>'
                    : '';
                html += `
            <div class="search-result" 
                 onclick="handleSearchResultClick(${JSON.stringify(safeResult)
                        .replace(/"/g, '&quot;')
                        .replace(/</g, '\\u003c')
                        .replace(/>/g, '\\u003e')})">
                <h4>№${result.Номер_в_издании} · ${result.Название}</h4>
                <div class="meta">
                    <span class="sender">${result.Отправитель}</span> → 
                    <span class="receiver">${result.Получатель}</span>
                </div>
                ${result.excerpt ? `<div class="excerpt">${highlightTerms(result.excerpt, queryTerms)}</div>` : ''}
            </div>
        `;
            });
            container.innerHTML = html;
        }
        function highlightTerms(text, terms, exactPhrase) {
            let highlighted = text;
            if (exactPhrase) {
                const escapedPhrase = exactPhrase.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                const phraseRegex = new RegExp(`(${escapedPhrase})`, 'gi');
                highlighted = highlighted.replace(phraseRegex, '<span class="highlight">$1</span>');
            }
            terms.forEach(term => {
                const escapedTerm = term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                const wordRegex = new RegExp(`\\b(${escapedTerm})\\b`, 'gi');
                highlighted = highlighted.replace(wordRegex, '<span class="highlight">$1</span>');
            });
            return highlighted;
        }
        document.getElementById('fullTextSearch').addEventListener('input', async function (e) {
            clearTimeout(searchTimeout);
            const query = e.target.value.trim();
            const resultsContainer = document.getElementById('searchResultsContainer');
            if (query.length < 2) {
                resultsContainer.innerHTML = '<div class="info-message">Введите минимум 2 символа</div>';
                return;
            }
            resultsContainer.innerHTML = `
                <div class="loading-state">
                    <div class="loading-spinner"></div>
                    <p>Поиск...</p>
                </div>
            `;
            searchTimeout = setTimeout(async () => {
                try {
                    const searchTerms = parseSearchQuery(query);
                    let exactResults = [];
                    if (searchTerms.exactPhrase) {
                        const exactResponse = await fetch(`http://localhost:5001/api/search?q=${encodeURIComponent(searchTerms.exactPhrase)}&exact=true`);
                        if (exactResponse.ok) {
                            exactResults = await exactResponse.json();
                        }
                    }
                    let wordResults = [];
                    if (searchTerms.words.length > 0) {
                        const wordResponse = await fetch(`http://localhost:5001/api/search?q=${encodeURIComponent(searchTerms.words.join(' '))}`);
                        if (wordResponse.ok) {
                            wordResults = await wordResponse.json();
                        }
                    }
                    const combinedResults = combineResults(exactResults, wordResults);
                    if (!combinedResults.length) {
                        resultsContainer.innerHTML = '<div class="info-message">Ничего не найдено</div>';
                        return;
                    }
                    displaySearchResults(combinedResults, query, resultsContainer);
                } catch (error) {
                    console.error('Ошибка поиска:', error);
                    resultsContainer.innerHTML = `
                        <div class="error-message">
                            <p>Ошибка соединения</p>
                            <p class="error-details">${error.message}</p>
                        </div>
                    `;
                }
            }, 1000);
        });
    </script>
    <div id="letterModal" class="letter-modal">
        <div class="letter-modal-content">
            <div class="letter-modal-header">
                <h3 id="letterModalTitle" class="letter-modal-title"></h3>
                <button class="letter-modal-close" onclick="closeLetterModal()">×</button>
            </div>
            <div class="letter-modal-container">
                <div class="letter-modal-text-container">
                    <div id="letterModalText" class="letter-modal-text"></div>
                </div>
                <div id="letterMetaInfo" class="letter-meta-container">
                    <div class="letter-meta-title">Метаинформация</div>
                    <div id="letterMetaContent"></div>
                </div>
            </div>
            <div class="letter-modal-footer">
                <button class="letter-modal-button" onclick="closeLetterModal()">Закрыть</button>
            </div>
        </div>
    </div>
</body>

</html>